//Dijkstra算法用于搜索加权图的最短路径
use std::time::Instant;
use std::cmp::Ordering;
use std::collections::{BinaryHeap, HashMap, HashSet};

//点定义
#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]
struct Vertex<'a> {
    name: &'a str,
}

impl<'a> Vertex<'a> {
    fn new(name: &'a str) -> Vertex<'a> {
        Vertex { name }
    }
}

//访问过的点
#[derive(Debug)]
struct Visited<V> {
    vertex: V,
    distance: usize, //距离
}
//为visited添加全序比较功能
impl<V> Ord for Visited<V> {
    fn cmp(&self, other: &Self) -> Ordering {
        other.distance.cmp(&self.distance)
    }
}

impl<V> PartialOrd for Visited<V> {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        Some(self.cmp(other))
    }
}
impl<V> Eq for Visited<V> {}

impl<V> PartialEq for Visited<V> {
    fn eq(&self, other: &Self) -> bool {
        self.distance.eq(&other.distance)
    }
}
//最短路径算法
fn dijkstra<'a> (
    start: Vertex<'a>,
    adj_list: &HashMap<Vertex<'a>, Vec<(Vertex<'a>, usize)>>) -> HashMap<Vertex<'a>, usize> {
    let mut distances = HashMap::new(); //距离
    let mut visited = HashSet::new(); //已访问的点
    let mut to_visit = BinaryHeap::new(); //待访问 的点
    //设置起始点和初始距离各点的距离
    distances.insert(start, 0);
    to_visit.push(Visited {
        vertex: start,
        distance: 0,
    });
    while let Some(Visited {vertex, distance}) = to_visit.pop() {
        //已经访问过该点，继续下一个点
        if !visited.insert(vertex) { continue;}
        //获取邻点
        if let Some(nbrs) = adj_list.get(&vertex) {
            for (nbr, cost) in nbrs {
                let new_dist = distance + cost;
                let is_shorter = distances.get(&nbr)
                                          .map_or(true, |&curr| new_dist < curr);
                //若距离更近，则插入新距离和邻点
                if is_shorter {
                    distances.insert(*nbr, new_dist);
                    to_visit.push(Visited{
                        vertex: *nbr,
                        distance: new_dist,
                    });
                }
            }
        }
    }
    distances
}

fn main(){
    let s_time = Instant::now();
    let v1 = Vertex::new("V1");
    let v2 = Vertex::new("V2");
    let v3 = Vertex::new("V3");
    let v4 = Vertex::new("V4");
    let v5 = Vertex::new("V5");
    let v6 = Vertex::new("V6");
    let v7 = Vertex::new("V7");

    let mut adj_list = HashMap::new();
    adj_list.insert(v1, vec![(v4, 7), (v2, 13)]);
    adj_list.insert(v2, vec![(v6, 5)]);
    adj_list.insert(v3, vec![(v2, 3), (v6, 9), (v5, 10)]);
    adj_list.insert(v4, vec![(v3, 1), (v5, 14)]);
    adj_list.insert(v5, vec![(v7, 20)]);
    adj_list.insert(v6, vec![(v5, 2), (v7, 30)]);
    let distances = dijkstra(v1, &adj_list);
    
    for (v, d) in &distances {
        println!("{} - {}, min distance: {d}", v1.name, v.name);
    }
    println!("Time cost: {:?}ms", s_time.elapsed().as_millis());
}
